#include "Stack.hpp"

// Default constructor
template <typename T>
cop4530::Stack<T>::Stack() : elements() {}

// Copy constructor
template <typename T>
cop4530::Stack<T>::Stack(const Stack<T>& other) : elements(other.elements) {}

// Move constructor
template <typename T>
cop4530::Stack<T>::Stack(Stack<T>&& other) : elements(std::move(other.elements)) {}

// Destructor
template <typename T>
cop4530::Stack<T>::~Stack() {
    clear();
}

// Copy assignment operator
template <typename T>
cop4530::Stack<T>& cop4530::Stack<T>::operator=(const Stack<T>& other) {
    if (this != &other) { // Self-assignment check
        elements = other.elements; // Copy the elements
    }
    return *this;
}

// Move assignment operator
template <typename T>
cop4530::Stack<T>& cop4530::Stack<T>::operator=(Stack<T>&& other) {
    if (this != &other) { // Self-assignment check
        elements = std::move(other.elements); // Move the elements
    }
    return *this;
}

// Check if the stack is empty
template <typename T>
bool cop4530::Stack<T>::empty() const {
    return elements.empty();
}

// Clear the stack
template <typename T>
void cop4530::Stack<T>::clear() {
    elements.clear();
}

// Push element onto the stack
template <typename T>
void cop4530::Stack<T>::push(const T& x) {
    elements.push_back(x);
}

// Pop the top element from the stack
template <typename T>
void cop4530::Stack<T>::pop() {
    if (empty()) {
        throw std::out_of_range("Stack is empty. Cannot pop.");
    }
    elements.pop_back();
}

// Get a reference to the top element
template <typename T>
T& cop4530::Stack<T>::top() {
    if (empty()) {
        throw std::out_of_range("Stack is empty. Cannot access top.");
    }
    return elements.back();
}

// Get a const reference to the top element
template <typename T>
const T& cop4530::Stack<T>::top() const {
    if (empty()) {
        throw std::out_of_range("Stack is empty. Cannot access top.");
    }
    return elements.back();
}

// Get the number of elements in the stack
template <typename T>
int cop4530::Stack<T>::size() const {
    return static_cast<int>(elements.size());
}

// Print elements in the stack
template <typename T>
void cop4530::Stack<T>::print(std::ostream& os, char ofc) const {
    for (size_t i = 0; i < elements.size(); ++i) {
        os << elements[i];
        if (i != elements.size() - 1) {
            os << ofc; // Separator
        }
    }
}

// Overloaded output operator
template <typename T>
std::ostream& cop4530::operator<<(std::ostream& os, const Stack<T>& a) {
    a.print(os); // Use the print method
    return os;
}

// Equality operator
template <typename T>
bool cop4530::operator==(const Stack<T>& a, const Stack<T>& b) {
    return a.size() == b.size() && std::equal(a.elements.begin(), a.elements.end(), b.elements.begin());
}

// Inequality operator
template <typename T>
bool cop4530::operator!=(const Stack<T>& a, const Stack<T>& b) {
    return !(a == b); // Opposite of equality
}

// Less than or equal operator
template <typename T>
bool cop4530::operator<=(const Stack<T>& a, const Stack<T>& b) {
    auto it_a = a.elements.begin();
    auto it_b = b.elements.begin();

    while (it_a != a.elements.end() && it_b != b.elements.end()) {
        if (*it_a > *it_b) {
            return false;
        }
        ++it_a;
        ++it_b;
    }
    return it_a == a.elements.end(); // Check if a has been fully traversed
}